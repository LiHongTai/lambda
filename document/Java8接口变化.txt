java1.8前
	一个接口可以继承多个父接口
	接口继承：
		[public] interface <接口名> extends <父接口1>[,<父接口2>]
		{
		}
	规则:
		1.子接口会得到父接口的一切，包括方法，类变量
		2.如果两个父接口有相同的变量，使用子接口去访问同名的变量的时候，
			会报错:对<??>变量的引用不明确
			这时只能通过父接口名来调用变量
		3.如果多个父接口有相同的方法声明，不影响继承
		
java1.8之后
	1.增加了default方法和static方法，这两个方法都可以有方法体
	2.default 方法属于实例，即必须有实现类，才可以调用
	3.static  方法属于类(接口)
	4.接口里面的静态方法不能被继承，但是静态变量可以被继承
	5.如果一个类实现了多个接口，并且这些接口之间没有任何继承关系，那么如果这些接口同时存在相同的default方法
		会报错:不相关的默认方法
		如果多个接口有继承关系，那么默认方法会被子接口覆盖
	6.如果遇到多个继承，并且有相同的默认方法，实现类可以通过特殊语法指定要访问哪个接口的方法
		在实现类或者子接口重写默认方法，在方法里面写:
			<接口>.super.方法名([参数]);
	7.如果一个接口只有一个抽象方法，包括继承的，那么这个接口是一个函数式接口
		函数式接口，可以使用lambda表达式实现
	8.如果接口使用了一个注解 @FunctionalInterface,限定接口里面只能有一个抽象方法
	
	
内部类:
	1.如果在匿名内部类里面访问了局部变量（在方法里面定义的变量），那么局部变量必须是final的
		从java8开始，如果访问局部变量，会自动把局部变量改为final的
	2.匿名内部类访问实例变量,类变量没有区别
	3.代码里面没有使用new创建一个匿名内部类，就产生一个新的class文件，意味着匿名内部类只能使用一次
	4.在产生匿名内部类的同时也产生了实例，所以匿名内部类不可能是抽象的
	5.要么实现一个接口，要么继承一个父类，不能同时实现和继承
	
Lambda表达式
	函数式接口
		当接口里面只有一个抽象方法的时候，就是函数式接口，可以使用注解强制限定接口只有一个抽象方法
			@FunctionalInterface 注解的作用是用于在编译告诉编译器该接口只能有一个抽象方法
	Lambda表达式只能针对函数式接口使用，接口里面有静态方法和默认方法，也可以是函数式接口，因为只要满足只有一个抽象方法即可